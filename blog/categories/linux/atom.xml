<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | SagerXiao's Blog]]></title>
  <link href="http://sagerblog.github.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://sagerblog.github.com/"/>
  <updated>2013-01-15T14:57:30+08:00</updated>
  <id>http://sagerblog.github.com/</id>
  <author>
    <name><![CDATA[Sager Xiao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[配置Nginx和uWsig服务开机自动启动]]></title>
    <link href="http://sagerblog.github.com/blog/2013/01/15/linux-service-auto-startup/"/>
    <updated>2013-01-15T14:53:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2013/01/15/linux-service-auto-startup</id>
    <content type="html"><![CDATA[<h3>1.配置Nginx服务开机自动启动</h3>

<h4>1.1创建 Nginx 开机启动脚本</h4>

<p><code>bash add auto run
vi /etc/init.d/nginx
</code>
将以下内容写到该脚本中
```bash auto start scripts</p>

<h1>!/bin/bash</h1>

<p>nginx=/usr/sbin/nginx
conf=/etc/nginx/nginx.conf</p>

<p>case $1 in</p>

<pre><code>start)
    echo -n "Starting Nginx"
    $nginx -c $conf
    echo " done"
;;

stop)
    echo -n "Stopping Nginx"
    $nginx -s stop
    echo " done"
;;

test)
    $nginx -t -c $conf
;;

reload)
    echo -n "Reloading Nginx"
    $nginx -s reload
    echo " done"
;;

restart)
    $0 stop
    $0 start
;;

show)
    ps -aux|grep nginx
;;

*)
    echo -n "Usage: $0 {start|restart|reload|stop|test|show}"
;;
</code></pre>

<p>esac
```</p>

<h4>1.2为 nginx.sh 脚本设置可执行属性</h4>

<p><code>bash executable
chmod +x /etc/init.d/nginx
</code></p>

<h4>1.3添加 Nginx 为系统服务（开机自动启动）</h4>

<p><code>bash add to sysconfig
chkconfig --add nginx
chkconfig nginx on
</code></p>

<h4>1.4启动 Nginx</h4>

<p><code>bash start service
service nginx start
</code></p>

<h4>1.5在不停止 Nginx 服务的情况下平滑变更 Nginx 配置</h4>

<p>修改 /usr/local/webserver/nginx/conf/nginx.conf 配置文件后，请执行以下命令检查配置文件是否正确：
<code>bash test config and reload
service nginx test
service nginx reload
</code></p>

<h3>2.配置uWsgi服务开机自动启动</h3>

<h4>2.1创建 uWsgi 开机启动脚本</h4>

<p><code>bash add auto run
vi /etc/init.d/uwsgi
</code>
将以下内容写到该脚本中
```bash auto start scripts</p>

<h1>!/bin/bash</h1>

<p>uwsgi=/usr/bin/uwsgi
api_conf=/etc/uwsgi/apps-enabled/project-api.ini
web_conf=/etc/uwsgi/apps-enabled/project-web.ini</p>

<p>case $1 in</p>

<pre><code>start)
    echo -n "Starting uWsgi"
    nohup $uwsgi -i $api_conf &gt;/var/log/uwsgi/project-api.log 2&gt;&amp;1 &amp;
    nohup $uwsgi -i $web_conf &gt;/var/log/uwsgi/project-web.log 2&gt;&amp;1 &amp;
    echo " done"
;;

stop)
    echo -n "Stopping uWsgi"
    killall -9 uwsgi
    echo " done"
;;

restart)
    $0 stop
    $0 start
;;

show)
    ps -ef|grep uwsgi
;;

*)
    echo -n "Usage: $0 {start|restart|stop|show}"
;;
</code></pre>

<p>esac
```</p>

<h4>2.2为 uwsgi 脚本设置可执行属性</h4>

<p><code>bash executable
chmod +x /etc/init.d/uwsgi
</code></p>

<h4>2.3添加 uWsgi 为系统服务（开机自动启动）</h4>

<p><code>bash add to sysconfig
chkconfig --add uwsgi
chkconfig uwsgi on
</code></p>

<h4>2.4启动 uWsgi</h4>

<p><code>bash start service
service uwsgi start
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux配置Nginx+uWsgi环境]]></title>
    <link href="http://sagerblog.github.com/blog/2013/01/15/linux-nginx-uwsgi/"/>
    <updated>2013-01-15T12:49:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2013/01/15/linux-nginx-uwsgi</id>
    <content type="html"><![CDATA[<p>转Python后碰到的最大的问题就是服务器配置，产品环境最终还是需要用到Nginx+uWsgi，折腾过好久，把操作记录放在这里，方便查询</p>

<p>我的环境：RHEL6，python2.6.6，Nginx1.2.6，uWsgi1.4.4（都是从官方网站下载的最新版本）</p>

<h3>1.环境准备</h3>

<p>先更新系统，并安装编译环境等等。
```bash Prepare environment
yum update
yum install glib2-devel openssl-devel pcre-devel bzip2-devel gzip-devel\</p>

<pre><code>python python-devel libxml2 libxml2-devel python-setuptools zlib-devel\
wget pcre pcre-devel sudo gcc make autoconf automake
</code></pre>

<p>```</p>

<h3>2.编译安装Nginx</h3>

<p>先到<a href="http://nginx.org/en/download.html">Nginx官网</a>下载最新稳定版本的Nginx1.2.6，编译安装</p>

<!--more-->


<p><code>bash Compile and install nginx
cd /usr/local/src
wget http://nginx.org/download/nginx-1.2.6.tar.gz
tar -zxvf nginx-1.2.6.tar.gz
cd nginx-1.2.6
./configure \
    --user=nginx \
    --group=nginx \
    --prefix=/usr/share \
    --sbin-path=/usr/sbin/nginx \
    --conf-path=/etc/nginx/nginx.conf \
    --error-log-path=/var/log/nginx/error.log \
    --http-log-path=/var/log/nginx/access.log \
    --pid-path=/var/log/run/nginx.pid \
    --lock-path=/var/log/lock/subsys/nginx \
    --with-http_ssl_module \
    --with-http_realip_module \
    --with-http_addition_module \
    --with-http_sub_module \
    --with-http_dav_module \
    --with-http_flv_module \
    --with-http_gzip_static_module \
    --with-http_stub_status_module \
    --with-mail \
    --with-mail_ssl_module
make
make install
</code>
更多的编译选项参考：<a href="http://wiki.nginx.org/NginxInstallOptions">http://wiki.nginx.org/NginxInstallOptions</a></p>

<h3>3.Nginx环境配置</h3>

<h4>3.1为Nginx建立用户</h4>

<p><code>bash add user nginx
useradd -c "Nginx user" -s /bin/false -r -d /var/lib/nginx nginx
adduser --system --no-create-home  nginx
</code></p>

<h4>3.2运行Nginx</h4>

<p><code>bash run nginx
/usr/sbin/nginx
</code></p>

<h4>3.3配置文件</h4>

<p><code>bash nginx conf
/etc/nginx/nginx.conf
echo "NGINX_CONF_FILE=/etc/nginx/nginx.conf" &gt; /etc/sysconfig/nginx
</code></p>

<h3>4.编译安装uWsgi</h3>

<p>进入uWsgi的<a href="http://projects.unbit.it/uwsgi/">官方网站</a>，下载它的当前稳定版本，我这里下载的是1.4.4版本。
<code>bash Compiler and install uWsgi
cd /usr/local/src
wget http://projects.unbit.it/downloads/uwsgi-1.4.4.tar.gz
tar -zxvf uwsgi-1.4.4.tar.gz
mv uwsgi-1.4.4 uwsgi
cd uwsgi
python setup.py build
make
mv uwsgi /usr/bin  #move execuable file to /usr/bin
</code></p>

<h3>5.配置uWsgi</h3>

<p>详细配置方式可以参考官网上的配置说明：<a href="http://projects.unbit.it/uwsgi/wiki/Quickstart">http://projects.unbit.it/uwsgi/wiki/Quickstart</a>
我以项目中的两个模块配置文件示例如下（web模块和api模块，分别走两个不同的端口）
<code>bash web.ini config for uwsgi
[uwsgi]
autoload = true
master = true
uid=sager
gid=sager
workers = 2
socket = 127.0.0.1:8081
module = web-uwsgi
chdir = /home/sager/project
pythonpath = /opt/pyenv
virtualenv = /opt/pyenv
</code>
<code>bash api.ini config for uwsgi
[uwsgi]
autoload = true
uid=sager
gid=sager
master = true
workers =2
socket = 127.0.0.1:8080
module = api-uwsgi
chdir = /home/sager/project
pythonpath = /opt/pyenv
virtualenv = /opt/pyenv
</code></p>

<h3>6.启动Nginx和uWsgi服务</h3>

<p><code>bash start service
nginx
uwsgi -i api.ini
uwsgi -i web.ini
</code></p>

<h3>7.配置Nginx支持uWsgi</h3>

<p>简化的nginx.conf文件，增加一条include内容，见最后一行
```bash nginx.conf
user  nginx;
worker_processes  1;
events {</p>

<pre><code>worker_connections  1024;
</code></pre>

<p>}
http {</p>

<pre><code>include       mime.types; 
default_type  application/octet-stream; 
sendfile        on; 
keepalive_timeout  65; 
include /etc/nginx/sites-enabled/*; 
</code></pre>

<p>}
<code>
然后在/etc/nginx/sites-enabled目录中增加单个的server配置内容，参考如下
</code>bash sager-project.conf
server {</p>

<pre><code>listen 80; 
server_name localhost;  
location /api/ { 
    rewrite ^/api/(.*)$ /$1 break; 
    include uwsgi_params; 
    uwsgi_pass 127.0.0.1:8080;  
} 
location / { 
    include uwsgi_params; 
    uwsgi_pass 127.0.0.1:8081;  
} 
</code></pre>

<p>}
```
重启服务后，通过http://localhost即可访问项目主页了，web的请求会直接转发给8081端口，而http://localhost/api的请求则会转发到8080端口</p>

<p>至此，我们的配置完成了，可以参考下一篇文章，将nginx和uwsgi配置为系统服务，并开机自动启动</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最有用的Linux命令列表]]></title>
    <link href="http://sagerblog.github.com/blog/2013/01/08/most-useful-linux-shell/"/>
    <updated>2013-01-08T14:45:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2013/01/08/most-useful-linux-shell</id>
    <content type="html"><![CDATA[<h3>$ sudo !!</h3>

<p><strong><em>Run the last command as root</em></strong></p>

<p>Useful when you forget to use sudo for a command. "!!" grabs the last run command.</p>

<hr />

<h3>$ python -m SimpleHTTPServer</h3>

<p><strong><em>Serve current directory tree at http://localhost:8000/</em></strong></p>

<hr />

<h3>$ :w !sodu tee %</h3>

<p><strong><em>Save a file you edited in vim without the needed permissions</em></strong></p>

<p>I often forget to sudo before editing a file I don't have write permissions on. When you come to save that file and get the infamous "E212: Can't open file for writing", just issue that vim command in order to save the file without the need to save it to a temp file and then copy it back again.</p>

<!--more-->


<hr />

<h3>$ cd -</h3>

<p><strong><em>change to the previous working directory</em></strong></p>

<hr />

<h3>$ ^foo ^bar</h3>

<p><strong><em>Runs previous command but replacing</em></strong></p>

<p>Really useful for when you have a typo in a previous command. Also, arguments default to empty so if you accidentally run:
<code>
echo "no typozs"
</code>
you can correct it with
```
^z</p>

<h2>```</h2>

<h3>$ mtr google.com</h3>

<p><strong><em>mtr, better than traceroute and ping combined</em></strong></p>

<p>mtr combines the functionality of the traceroute and ping programs in a single network diagnostic tool.
As mtr starts, it investigates the network connection between the host mtr runs on and HOSTNAME. by sending packets with purposly low TTLs. It continues to send packets with low TTL, noting the response time of the intervening routers. This allows mtr to print the response percentage and response times of the internet route to HOSTNAME. A sudden increase in packetloss or response time is often an indication of a bad (or simply over?loaded) link.</p>

<hr />

<h3>$ ctrl-x e</h3>

<p><strong><em>Rapidly invoke an editor to write a long, complex, or tricky command</em></strong></p>

<p>Next time you are using your shell, try typing ctrl-x e (that is holding control key press x and then e). The shell will take what you've written on the command line thus far and paste it into the editor specified by $EDITOR. Then you can edit at leisure using all the powerful macros and commands of vi, emacs, nano, or whatever.</p>

<hr />

<h3>$ &lt;space>command</h3>

<p><strong><em>Execute a command without saving it in the history</em></strong></p>

<p>Prepending one or more spaces to your command won't be saved in history.
Useful for pr0n or passwords on the commandline.
Tested on BASH.</p>

<hr />

<h3>$ file.txt</h3>

<p><strong><em>Empty a file</em></strong></p>

<p>For when you want to flush all content from a file without removing it (hat-tip to Marc Kilgus).</p>

<hr />

<h3>$ $ssh-copy-id user@host</h3>

<p><strong><em>Copy ssh keys to user@host to enable password-less ssh logins.</em></strong></p>

<hr />

<h3>$ reset</h3>

<p><strong><em>Salvage a borked terminal</em></strong></p>

<p>If you bork your terminal by sending binary data to STDOUT or similar, you can get your terminal back using this command rather than killing and restarting the session. Note that you often won't be able to see the characters as you type them.</p>

<hr />

<h3>$ ffmpeg -f X11grab -s wxga -r 25 -i :0.0 -sameq /tmp/out.mpg</h3>

<p><strong><em>Capture video of a linux desktop</em></strong></p>

<hr />

<h3>$ 'ALT+.' or '&lt;ESC> .'</h3>

<p><strong><em>Place the argument of the most recent command on the shell</em></strong></p>

<p>When typing out long arguments, such as:
<code>
cp file.txt /var/www/wp-content/uploads/2009/03/
</code>
You can put that argument on your command line by holding down the ALT key and pressing the period '.' or by pressing <ESC> then the period '.'. For example:
<code>
cd 'ALT+.'
</code>
would put '/var/www/wp-content/uploads/2009/03/ as my argument. Keeping pressing 'ALT+.' to cycle through arguments of your commands starting from most recent to oldest. This can save a ton of typing.</p>

<hr />

<h3>$ mount | column -t</h3>

<p><strong><em>currently mounted filesystems in nice layout</em></strong></p>

<p>Particularly useful if you're mounting different drives, using the following command will allow you to see all the filesystems currently mounted on your computer and their respective specs with the added benefit of nice formatting.</p>

<hr />

<h3>$ ssh -N -L2001:localhost:80 somemachine</h3>

<p><strong><em>start a tunnel from some machine's port 80 to your local post 2001</em></strong></p>

<p>now you can acces the website by going to http://localhost:2001/</p>

<hr />

<h3>$ echo "ls -l" | at midnight</h3>

<p><strong><em>Execute a command at a given time</em></strong></p>

<p>This is an alternative to cron which allows a one-off task to be scheduled for a certain time.</p>

<hr />

<h3>$ dig +short text <keyword>.wp.dg.cx</h3>

<p><strong><em>Query Wikipedia via console over DNS</em></strong></p>

<p>Query Wikipedia by issuing a DNS query for a TXT record. The TXT record will also include a short URL to the complete corresponding Wikipedia entry.You can also write a little shell script like:
```bash
$ cat wikisole.sh</p>

<h1>!/bin/sh</h1>

<p>dig +short txt ${1}.wp.dg.cx
<code>
and run it like
</code>
$ ./wikisole.sh unix
```
were your first option ($1) will be used as search term.</p>

<hr />

<h3>$ netstat -tlnp</h3>

<p><strong><em>Lists all listening ports together with the PID of the associated process</em></strong></p>

<p>The PID will only be printed if you're holding a root equivalent ID.</p>

<hr />

<h3>$ dd if=/dev/dsp | ssh -c arcfour -C username@host dd of=/dev/dsp</h3>

<p><strong><em>output your microphone to a remote computer's speaker</em></strong></p>

<p>This will output the sound from your microphone port to the ssh target computer's speaker port. The sound quality is very bad, so you will hear a lot of hissing.</p>

<hr />

<h3>$ curl -u user:pass -d status="Tweeting from the shell" http://twitter.com/statuses/update.xml</h3>

<p><strong><em>Update twitter via curl</em></strong></p>

<hr />

<h3>$ !!:gs/foo/bar</h3>

<p><strong><em>Runs previous command replacing foo by bar every time that foo appears</em></strong></p>

<p>Very useful for rerunning a long command changing some arguments globally.
As opposed to ^foo ^bar, which only replaces the first occurrence of foo, this one changes every occurrence.</p>

<hr />

<h3>$ mount -t tmpfs tmps /mnt -o size=1024m</h3>

<p><strong><em>Mount a temporary ram partition</em></strong></p>

<p>Makes a partition in ram which is useful if you need a temporary working space as read/write access is fast.</p>

<p>Be aware that anything saved in this partition will be gone after your computer is turned off.</p>

<hr />

<h3>$ man ascii</h3>

<p><strong><em>Quick access to the ascii table.</em></strong></p>

<hr />

<h3>$ sshfs name@server:/path/to/folder /path/to/mound/point</h3>

<p><strong><em>Mount folder/filesystem through SSH</em></strong></p>

<p>Install SSHFS from http://fuse.sourceforge.net/sshfs.html</p>

<p>Will allow you to mount a folder security over a network.</p>

<hr />

<h3>$ curl ifconfig.me</h3>

<p><strong><em>Get your external IP address</em></strong></p>

<p>curl ifconfig.me/ip -> IP Adress</p>

<p>curl ifconfig.me/host -> Remote Host</p>

<p>curl ifconfig.me/ua ->User Agent</p>

<p>curl ifconfig.me/port -> Port</p>

<p>curl ifconfig.me/all -> All</p>

<p>thanks to <a href="http://ifconfig.me/">ifconfig.me</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu安装Dropbox后无法连接服务器的解决方法]]></title>
    <link href="http://sagerblog.github.com/blog/2012/12/26/ubuntu-dropbox/"/>
    <updated>2012-12-26T07:50:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2012/12/26/ubuntu-dropbox</id>
    <content type="html"><![CDATA[<p>由于工作需要，操作系统从Mac换到了Ubuntu，现在这个年代，谁没个云存储啥的，Dropbox当然是首选（通过某些方式已经将免费空间提升到25G了），装完Ubuntu后第一个事情就是装Dropbox。</p>

<p>于是我就马不停蹄地下载了Dropbox的安装包然后装到Ubuntu上，装完一打开，弹出这么个提示：“Trouble connecting to Dropbox server.Maybe your internet connection is down,or you need to set your http_proxy environment variable”，主要意思就说无法连接上dropbox的服务器。</p>

<p>然后我把hosts改了，问题依旧…，只有祭出google大神了</p>

<!--more-->


<p>原来装了那个deb包还不算装完，第一次启动时还要下载一个.tar.gz的包，明显这个包的地址在墙外了。</p>

<p>所以需要到这个地址 <a href="http://www.getdropbox.com/download?plat=lnx.x86">http://www.getdropbox.com/download?plat=lnx.x86</a> 下载这个.tar.gz包，当然要先爬墙。（我把这个文件传到了华为网盘 <a href="http://dl.vmall.com/c0sgq6m4m6">http://dl.vmall.com/c0sgq6m4m6</a> ，无法爬墙的同学如果信得过我的话可以下载）</p>

<p>然后在下载到的dropbox-lnx.x86-1.2.52.tar.gz文件解压到主文件夹，是个隐藏文件夹.dropbox-dist, 按“Ctrl + h”显示隐藏文件</p>

<p>最后打开dropbox即可正常使用啦～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox中复制使用虚拟硬盘]]></title>
    <link href="http://sagerblog.github.com/blog/2012/12/24/copy-virtualbox-hd/"/>
    <updated>2012-12-24T22:56:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2012/12/24/copy-virtualbox-hd</id>
    <content type="html"><![CDATA[<p>VirtualBox可不像VMware那样，直接复制虚拟磁盘文件就可以了事的，只因为VirtualBox识别虚拟磁盘文件VDI采用了uuid识别技术。</p>

<p>由于测试需要搭建局域网环境，需要两台虚拟机同时运行。当我安装完一个虚拟系统时，我将虚拟磁盘文件复制一份重新创建虚拟系统时提示打开虚拟硬盘 windowsxp.vdi 失败。</p>

<pre><code>Cannot register the hard disk 'windowsxp.vdi' with UUID {24eb969f-8c98-470d-b2dd-35318f2b8860} 
because a hard disk 'windowsxp.vdi' with UUID {24eb969f-8c98-470d-b2dd-35318f2b8860} already exists 
in the media registry ('/home/sager/VirtualBox VMs/windowsxp/windowsxp.vid').
</code></pre>

<p>往Google里找寻了一番，原来Virtualbox也是有VBoxManage命令的,于是我决定给复制的vdi文件重新分配uuid。</p>

<!-- more -->


<p><code>bash 重新分配uuid
sager@sager-desktop:~/VirtualBox VMs/WinXP&gt;VBoxManage internalcommands sethduuid windowsxp.vdi
UUID changed to: c8acda7d-149d-4157-affb-2d2dbc1bab7
</code>
接着就可以使用拷贝的vdi文件正常的创建第二台虚拟机了。</p>

<p>当然如果你没有直接复制vdi文件,那么直接用Virtualbox自带的克隆vdi文件命令。
<code>bash 自带克隆vdi文件
sager@sager-desktop:~/VirtualBox VMs/WinXP&gt;VBoxManage clonehd windowsxp.vdi winxp.clone.vdi
</code></p>

<p>Virualbox的快照功能非常不错,可以即时恢复到快照时的状态，做试验就不用重新配环境了。</p>
]]></content>
  </entry>
  
</feed>
