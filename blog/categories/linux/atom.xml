<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | SagerXiao's Blog]]></title>
  <link href="http://sagerblog.github.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://sagerblog.github.com/"/>
  <updated>2013-01-16T14:09:58+08:00</updated>
  <id>http://sagerblog.github.com/</id>
  <author>
    <name><![CDATA[Sager Xiao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RPM使用详解]]></title>
    <link href="http://sagerblog.github.com/blog/2013/01/16/rpm-command/"/>
    <updated>2013-01-16T14:03:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2013/01/16/rpm-command</id>
    <content type="html"><![CDATA[<h3>RPM使用详解</h3>

<p>在Linux操作系统中，有一个系统软件包，它的功能类似于Windows里面的“添加/删除程序”，但是功能又比“添加/删除程序”强很多，它就是Red Hat Package Manager(简称RPM)。此工具包最先是由Red Hat公司推出的，后来被其他Linux开发商所借用。由于它为Linux使用者省去了很多时间，所以被广泛应用于在Linux下安装、删除软件。下面就给大家介绍一下它的具体使用方法。</p>

<p>1.我们得到一个新软件，在安装之前，一般都要先查看一下这个软件包里有什么内容，假设这个文件是：Linux-1.4-6.i368.rpm，我们可以用这条命令查看：</p>

<p>rpm -qpi Linux-1.4-6.i368.rpm</p>

<p>系统将会列出这个软件包的详细资料，包括含有多少个文件、各文件名称、文件大小、创建时间、编译日期等信息。</p>

<!--more-->


<p>2.上面列出的所有文件在安装时不一定全部安装，就像Windows下程序的安装方式分为典型、完全、自定义一样，Linux也会让你选择安装方式，此时我们可以用下面这条命令查看软件包将会在系统里安装哪些部分，以方便我们的选择：</p>

<p>rpm -qpl Linux-1.4-6.i368.rpm</p>

<p>3.选择安装方式后，开始安装。我们可以用rpm-ivh Linux-1.4-6.i368.rpm命令安装此软件。在安装过程中，若系统提示此软件已安装过或因其他原因无法继续安装，但若我们确实想执行安装命令，可以在 -ivh后加一参数“-replacepkgs”：</p>

<p>rpm -ivh -replacepkgs Linux-1.4-6.i368.rpm</p>

<p>4.有时我们卸载某个安装过的软件，只需执行rpm-e &lt;文件名>命令即可。</p>

<p>5.对低版本软件进行升级是提高其功能的好办法，这样可以省去我们卸载后再安装新软件的麻烦，要升级某个软件，只须执行如下命令：rpm -uvh &lt;文件名>，注意：此时的文件名必须是要升级软件的升级补丁</p>

<p>6.另外一个安装软件的方法可谓是Linux的独到之处，同时也是RMP强大功能的一个表现：通过FTP站点直接在线安装软件。当找到含有你所需软件的站点并与此网站连接后，执行下面的命令即可实现在线安装，譬如在线安装Linux-1.4-6.i368.rpm，可以用命令：</p>

<p>rpm -i ftp://ftp.pht.com/pub/linux/redhat/...-1.4-6.i368.rpm</p>

<p>7.在我们使用电脑过程中，难免会有误操作，若我们误删了几个文件而影响了系统的性能时，怎样查找到底少了哪些文件呢?RPM软件包提供了一个查找损坏文件的功能，执行此命令：rpm -Va即可，Linux将为你列出所有损坏的文件。你可以通过Linux的安装光盘进行修复。</p>

<p>8.Linux系统中文件繁多，在使用过程中，难免会碰到我们不认识的文件，在Windows下我们可以用“开始/查找”菜单快速判断某个文件属于哪个文件夹，在Linux中，下面这条命令行可以帮助我们快速判定某个文件属于哪个软件包：</p>

<p>rpm -qf &lt;文件名></p>

<p>9.当每个软件包安装在Linux系统后，安装文件都会到RPM数据库中“报到”，所以，我们要查询某个已安装软件的属性时，只需到此数据库中查找即可。注意：此时的查询命令不同于1和8介绍的查询，这种方法只适用于已安装过的软件包！命令格式：</p>

<p>rpm -参数　&lt;文件名></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[配置Nginx和uWsig服务开机自动启动]]></title>
    <link href="http://sagerblog.github.com/blog/2013/01/15/linux-service-auto-startup/"/>
    <updated>2013-01-15T14:53:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2013/01/15/linux-service-auto-startup</id>
    <content type="html"><![CDATA[<h3>1.配置Nginx服务开机自动启动</h3>

<h4>1.1创建 Nginx 开机启动脚本</h4>

<p><code>bash add auto run
vi /etc/init.d/nginx
</code>
将以下内容写到该脚本中</p>

<!--more-->


<p>```bash auto start scripts</p>

<h1>!/bin/bash</h1>

<p>nginx=/usr/sbin/nginx
conf=/etc/nginx/nginx.conf</p>

<p>case $1 in</p>

<pre><code>start)
    echo -n "Starting Nginx"
    $nginx -c $conf
    echo " done"
;;

stop)
    echo -n "Stopping Nginx"
    $nginx -s stop
    echo " done"
;;

test)
    $nginx -t -c $conf
;;

reload)
    echo -n "Reloading Nginx"
    $nginx -s reload
    echo " done"
;;

restart)
    $0 stop
    $0 start
;;

show)
    ps -aux|grep nginx
;;

*)
    echo -n "Usage: $0 {start|restart|reload|stop|test|show}"
;;
</code></pre>

<p>esac
```</p>

<h4>1.2为 nginx.sh 脚本设置可执行属性</h4>

<p><code>bash executable
chmod +x /etc/init.d/nginx
</code></p>

<h4>1.3添加 Nginx 为系统服务（开机自动启动）</h4>

<p><code>bash add to sysconfig
chkconfig --add nginx
chkconfig nginx on
</code></p>

<h4>1.4启动 Nginx</h4>

<p><code>bash start service
service nginx start
</code></p>

<h4>1.5在不停止 Nginx 服务的情况下平滑变更 Nginx 配置</h4>

<p>修改 /usr/local/webserver/nginx/conf/nginx.conf 配置文件后，请执行以下命令检查配置文件是否正确：
<code>bash test config and reload
service nginx test
service nginx reload
</code></p>

<h3>2.配置uWsgi服务开机自动启动</h3>

<h4>2.1创建 uWsgi 开机启动脚本</h4>

<p><code>bash add auto run
vi /etc/init.d/uwsgi
</code>
将以下内容写到该脚本中
```bash auto start scripts</p>

<h1>!/bin/bash</h1>

<p>uwsgi=/usr/bin/uwsgi
api_conf=/etc/uwsgi/apps-enabled/project-api.ini
web_conf=/etc/uwsgi/apps-enabled/project-web.ini</p>

<p>case $1 in</p>

<pre><code>start)
    echo -n "Starting uWsgi"
    nohup $uwsgi -i $api_conf &gt;/var/log/uwsgi/project-api.log 2&gt;&amp;1 &amp;
    nohup $uwsgi -i $web_conf &gt;/var/log/uwsgi/project-web.log 2&gt;&amp;1 &amp;
    echo " done"
;;

stop)
    echo -n "Stopping uWsgi"
    killall -9 uwsgi
    echo " done"
;;

restart)
    $0 stop
    $0 start
;;

show)
    ps -ef|grep uwsgi
;;

*)
    echo -n "Usage: $0 {start|restart|stop|show}"
;;
</code></pre>

<p>esac
```</p>

<h4>2.2为 uwsgi 脚本设置可执行属性</h4>

<p><code>bash executable
chmod +x /etc/init.d/uwsgi
</code></p>

<h4>2.3添加 uWsgi 为系统服务（开机自动启动）</h4>

<p><code>bash add to sysconfig
chkconfig --add uwsgi
chkconfig uwsgi on
</code></p>

<h4>2.4启动 uWsgi</h4>

<p><code>bash start service
service uwsgi start
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux配置Nginx+uWsgi环境]]></title>
    <link href="http://sagerblog.github.com/blog/2013/01/15/linux-nginx-uwsgi/"/>
    <updated>2013-01-15T12:49:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2013/01/15/linux-nginx-uwsgi</id>
    <content type="html"><![CDATA[<p>转Python后碰到的最大的问题就是服务器配置，产品环境最终还是需要用到Nginx+uWsgi，折腾过好久，把操作记录放在这里，方便查询</p>

<p>我的环境：RHEL6，python2.6.6，Nginx1.2.6，uWsgi1.4.4（都是从官方网站下载的最新版本）</p>

<h3>1.环境准备</h3>

<p>先更新系统，并安装编译环境等等。
```bash Prepare environment
yum update
yum install glib2-devel openssl-devel pcre-devel bzip2-devel gzip-devel\</p>

<pre><code>python python-devel libxml2 libxml2-devel python-setuptools zlib-devel\
wget pcre pcre-devel sudo gcc make autoconf automake
</code></pre>

<p>```</p>

<h3>2.编译安装Nginx</h3>

<p>先到<a href="http://nginx.org/en/download.html">Nginx官网</a>下载最新稳定版本的Nginx1.2.6，编译安装</p>

<!--more-->


<p><code>bash Compile and install nginx
cd /usr/local/src
wget http://nginx.org/download/nginx-1.2.6.tar.gz
tar -zxvf nginx-1.2.6.tar.gz
cd nginx-1.2.6
./configure \
    --user=nginx \
    --group=nginx \
    --prefix=/usr/share \
    --sbin-path=/usr/sbin/nginx \
    --conf-path=/etc/nginx/nginx.conf \
    --error-log-path=/var/log/nginx/error.log \
    --http-log-path=/var/log/nginx/access.log \
    --pid-path=/var/log/run/nginx.pid \
    --lock-path=/var/log/lock/subsys/nginx \
    --with-http_ssl_module \
    --with-http_realip_module \
    --with-http_addition_module \
    --with-http_sub_module \
    --with-http_dav_module \
    --with-http_flv_module \
    --with-http_gzip_static_module \
    --with-http_stub_status_module \
    --with-mail \
    --with-mail_ssl_module
make
make install
</code>
更多的编译选项参考：<a href="http://wiki.nginx.org/NginxInstallOptions">http://wiki.nginx.org/NginxInstallOptions</a></p>

<h3>3.Nginx环境配置</h3>

<h4>3.1为Nginx建立用户</h4>

<p><code>bash add user nginx
useradd -c "Nginx user" -s /bin/false -r -d /var/lib/nginx nginx
adduser --system --no-create-home  nginx
</code></p>

<h4>3.2运行Nginx</h4>

<p><code>bash run nginx
/usr/sbin/nginx
</code></p>

<h4>3.3配置文件</h4>

<p><code>bash nginx conf
/etc/nginx/nginx.conf
echo "NGINX_CONF_FILE=/etc/nginx/nginx.conf" &gt; /etc/sysconfig/nginx
</code></p>

<h3>4.编译安装uWsgi</h3>

<p>进入uWsgi的<a href="http://projects.unbit.it/uwsgi/">官方网站</a>，下载它的当前稳定版本，我这里下载的是1.4.4版本。
<code>bash Compiler and install uWsgi
cd /usr/local/src
wget http://projects.unbit.it/downloads/uwsgi-1.4.4.tar.gz
tar -zxvf uwsgi-1.4.4.tar.gz
mv uwsgi-1.4.4 uwsgi
cd uwsgi
python setup.py build
make
mv uwsgi /usr/bin  #move execuable file to /usr/bin
</code></p>

<h3>5.配置uWsgi</h3>

<p>详细配置方式可以参考官网上的配置说明：<a href="http://projects.unbit.it/uwsgi/wiki/Quickstart">http://projects.unbit.it/uwsgi/wiki/Quickstart</a>
我以项目中的两个模块配置文件示例如下（web模块和api模块，分别走两个不同的端口）
<code>bash web.ini config for uwsgi
[uwsgi]
autoload = true
master = true
uid=sager
gid=sager
workers = 2
socket = 127.0.0.1:8081
module = web-uwsgi
chdir = /home/sager/project
pythonpath = /opt/pyenv
virtualenv = /opt/pyenv
</code>
<code>bash api.ini config for uwsgi
[uwsgi]
autoload = true
uid=sager
gid=sager
master = true
workers =2
socket = 127.0.0.1:8080
module = api-uwsgi
chdir = /home/sager/project
pythonpath = /opt/pyenv
virtualenv = /opt/pyenv
</code></p>

<h3>6.启动Nginx和uWsgi服务</h3>

<p><code>bash start service
nginx
uwsgi -i api.ini
uwsgi -i web.ini
</code></p>

<h3>7.配置Nginx支持uWsgi</h3>

<p>简化的nginx.conf文件，增加一条include内容，见最后一行
```bash nginx.conf
user  nginx;
worker_processes  1;
events {</p>

<pre><code>worker_connections  1024;
</code></pre>

<p>}
http {</p>

<pre><code>include       mime.types; 
default_type  application/octet-stream; 
sendfile        on; 
keepalive_timeout  65; 
include /etc/nginx/sites-enabled/*; 
</code></pre>

<p>}
<code>
然后在/etc/nginx/sites-enabled目录中增加单个的server配置内容，参考如下
</code>bash sager-project.conf
server {</p>

<pre><code>listen 80; 
server_name localhost;  
location /api/ { 
    rewrite ^/api/(.*)$ /$1 break; 
    include uwsgi_params; 
    uwsgi_pass 127.0.0.1:8080;  
} 
location / { 
    include uwsgi_params; 
    uwsgi_pass 127.0.0.1:8081;  
} 
</code></pre>

<p>}
```
重启服务后，通过http://localhost即可访问项目主页了，web的请求会直接转发给8081端口，而http://localhost/api的请求则会转发到8080端口</p>

<p>至此，我们的配置完成了，可以参考下一篇文章，将nginx和uwsgi配置为系统服务，并开机自动启动</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最有用的Linux命令列表]]></title>
    <link href="http://sagerblog.github.com/blog/2013/01/08/most-useful-linux-shell/"/>
    <updated>2013-01-08T14:45:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2013/01/08/most-useful-linux-shell</id>
    <content type="html"><![CDATA[<h3>$ sudo !!</h3>

<p><strong><em>Run the last command as root</em></strong></p>

<p>Useful when you forget to use sudo for a command. "!!" grabs the last run command.</p>

<hr />

<h3>$ python -m SimpleHTTPServer</h3>

<p><strong><em>Serve current directory tree at http://localhost:8000/</em></strong></p>

<hr />

<h3>$ :w !sodu tee %</h3>

<p><strong><em>Save a file you edited in vim without the needed permissions</em></strong></p>

<p>I often forget to sudo before editing a file I don't have write permissions on. When you come to save that file and get the infamous "E212: Can't open file for writing", just issue that vim command in order to save the file without the need to save it to a temp file and then copy it back again.</p>

<!--more-->


<hr />

<h3>$ cd -</h3>

<p><strong><em>change to the previous working directory</em></strong></p>

<hr />

<h3>$ ^foo ^bar</h3>

<p><strong><em>Runs previous command but replacing</em></strong></p>

<p>Really useful for when you have a typo in a previous command. Also, arguments default to empty so if you accidentally run:
<code>
echo "no typozs"
</code>
you can correct it with
```
^z</p>

<h2>```</h2>

<h3>$ mtr google.com</h3>

<p><strong><em>mtr, better than traceroute and ping combined</em></strong></p>

<p>mtr combines the functionality of the traceroute and ping programs in a single network diagnostic tool.
As mtr starts, it investigates the network connection between the host mtr runs on and HOSTNAME. by sending packets with purposly low TTLs. It continues to send packets with low TTL, noting the response time of the intervening routers. This allows mtr to print the response percentage and response times of the internet route to HOSTNAME. A sudden increase in packetloss or response time is often an indication of a bad (or simply over?loaded) link.</p>

<hr />

<h3>$ ctrl-x e</h3>

<p><strong><em>Rapidly invoke an editor to write a long, complex, or tricky command</em></strong></p>

<p>Next time you are using your shell, try typing ctrl-x e (that is holding control key press x and then e). The shell will take what you've written on the command line thus far and paste it into the editor specified by $EDITOR. Then you can edit at leisure using all the powerful macros and commands of vi, emacs, nano, or whatever.</p>

<hr />

<h3>$ &lt;space>command</h3>

<p><strong><em>Execute a command without saving it in the history</em></strong></p>

<p>Prepending one or more spaces to your command won't be saved in history.
Useful for pr0n or passwords on the commandline.
Tested on BASH.</p>

<hr />

<h3>$ file.txt</h3>

<p><strong><em>Empty a file</em></strong></p>

<p>For when you want to flush all content from a file without removing it (hat-tip to Marc Kilgus).</p>

<hr />

<h3>$ $ssh-copy-id user@host</h3>

<p><strong><em>Copy ssh keys to user@host to enable password-less ssh logins.</em></strong></p>

<hr />

<h3>$ reset</h3>

<p><strong><em>Salvage a borked terminal</em></strong></p>

<p>If you bork your terminal by sending binary data to STDOUT or similar, you can get your terminal back using this command rather than killing and restarting the session. Note that you often won't be able to see the characters as you type them.</p>

<hr />

<h3>$ ffmpeg -f X11grab -s wxga -r 25 -i :0.0 -sameq /tmp/out.mpg</h3>

<p><strong><em>Capture video of a linux desktop</em></strong></p>

<hr />

<h3>$ 'ALT+.' or '&lt;ESC> .'</h3>

<p><strong><em>Place the argument of the most recent command on the shell</em></strong></p>

<p>When typing out long arguments, such as:
<code>
cp file.txt /var/www/wp-content/uploads/2009/03/
</code>
You can put that argument on your command line by holding down the ALT key and pressing the period '.' or by pressing <ESC> then the period '.'. For example:
<code>
cd 'ALT+.'
</code>
would put '/var/www/wp-content/uploads/2009/03/ as my argument. Keeping pressing 'ALT+.' to cycle through arguments of your commands starting from most recent to oldest. This can save a ton of typing.</p>

<hr />

<h3>$ mount | column -t</h3>

<p><strong><em>currently mounted filesystems in nice layout</em></strong></p>

<p>Particularly useful if you're mounting different drives, using the following command will allow you to see all the filesystems currently mounted on your computer and their respective specs with the added benefit of nice formatting.</p>

<hr />

<h3>$ ssh -N -L2001:localhost:80 somemachine</h3>

<p><strong><em>start a tunnel from some machine's port 80 to your local post 2001</em></strong></p>

<p>now you can acces the website by going to http://localhost:2001/</p>

<hr />

<h3>$ echo "ls -l" | at midnight</h3>

<p><strong><em>Execute a command at a given time</em></strong></p>

<p>This is an alternative to cron which allows a one-off task to be scheduled for a certain time.</p>

<hr />

<h3>$ dig +short text <keyword>.wp.dg.cx</h3>

<p><strong><em>Query Wikipedia via console over DNS</em></strong></p>

<p>Query Wikipedia by issuing a DNS query for a TXT record. The TXT record will also include a short URL to the complete corresponding Wikipedia entry.You can also write a little shell script like:
```bash
$ cat wikisole.sh</p>

<h1>!/bin/sh</h1>

<p>dig +short txt ${1}.wp.dg.cx
<code>
and run it like
</code>
$ ./wikisole.sh unix
```
were your first option ($1) will be used as search term.</p>

<hr />

<h3>$ netstat -tlnp</h3>

<p><strong><em>Lists all listening ports together with the PID of the associated process</em></strong></p>

<p>The PID will only be printed if you're holding a root equivalent ID.</p>

<hr />

<h3>$ dd if=/dev/dsp | ssh -c arcfour -C username@host dd of=/dev/dsp</h3>

<p><strong><em>output your microphone to a remote computer's speaker</em></strong></p>

<p>This will output the sound from your microphone port to the ssh target computer's speaker port. The sound quality is very bad, so you will hear a lot of hissing.</p>

<hr />

<h3>$ curl -u user:pass -d status="Tweeting from the shell" http://twitter.com/statuses/update.xml</h3>

<p><strong><em>Update twitter via curl</em></strong></p>

<hr />

<h3>$ !!:gs/foo/bar</h3>

<p><strong><em>Runs previous command replacing foo by bar every time that foo appears</em></strong></p>

<p>Very useful for rerunning a long command changing some arguments globally.
As opposed to ^foo ^bar, which only replaces the first occurrence of foo, this one changes every occurrence.</p>

<hr />

<h3>$ mount -t tmpfs tmps /mnt -o size=1024m</h3>

<p><strong><em>Mount a temporary ram partition</em></strong></p>

<p>Makes a partition in ram which is useful if you need a temporary working space as read/write access is fast.</p>

<p>Be aware that anything saved in this partition will be gone after your computer is turned off.</p>

<hr />

<h3>$ man ascii</h3>

<p><strong><em>Quick access to the ascii table.</em></strong></p>

<hr />

<h3>$ sshfs name@server:/path/to/folder /path/to/mound/point</h3>

<p><strong><em>Mount folder/filesystem through SSH</em></strong></p>

<p>Install SSHFS from http://fuse.sourceforge.net/sshfs.html</p>

<p>Will allow you to mount a folder security over a network.</p>

<hr />

<h3>$ curl ifconfig.me</h3>

<p><strong><em>Get your external IP address</em></strong></p>

<p>curl ifconfig.me/ip -> IP Adress</p>

<p>curl ifconfig.me/host -> Remote Host</p>

<p>curl ifconfig.me/ua ->User Agent</p>

<p>curl ifconfig.me/port -> Port</p>

<p>curl ifconfig.me/all -> All</p>

<p>thanks to <a href="http://ifconfig.me/">ifconfig.me</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu安装Dropbox后无法连接服务器的解决方法]]></title>
    <link href="http://sagerblog.github.com/blog/2012/12/26/ubuntu-dropbox/"/>
    <updated>2012-12-26T07:50:00+08:00</updated>
    <id>http://sagerblog.github.com/blog/2012/12/26/ubuntu-dropbox</id>
    <content type="html"><![CDATA[<p>由于工作需要，操作系统从Mac换到了Ubuntu，现在这个年代，谁没个云存储啥的，Dropbox当然是首选（通过某些方式已经将免费空间提升到25G了），装完Ubuntu后第一个事情就是装Dropbox。</p>

<p>于是我就马不停蹄地下载了Dropbox的安装包然后装到Ubuntu上，装完一打开，弹出这么个提示：“Trouble connecting to Dropbox server.Maybe your internet connection is down,or you need to set your http_proxy environment variable”，主要意思就说无法连接上dropbox的服务器。</p>

<p>然后我把hosts改了，问题依旧…，只有祭出google大神了</p>

<!--more-->


<p>原来装了那个deb包还不算装完，第一次启动时还要下载一个.tar.gz的包，明显这个包的地址在墙外了。</p>

<p>所以需要到这个地址 <a href="http://www.getdropbox.com/download?plat=lnx.x86">http://www.getdropbox.com/download?plat=lnx.x86</a> 下载这个.tar.gz包，当然要先爬墙。（我把这个文件传到了华为网盘 <a href="http://dl.vmall.com/c0sgq6m4m6">http://dl.vmall.com/c0sgq6m4m6</a> ，无法爬墙的同学如果信得过我的话可以下载）</p>

<p>然后在下载到的dropbox-lnx.x86-1.2.52.tar.gz文件解压到主文件夹，是个隐藏文件夹.dropbox-dist, 按“Ctrl + h”显示隐藏文件</p>

<p>最后打开dropbox即可正常使用啦～</p>
]]></content>
  </entry>
  
</feed>
